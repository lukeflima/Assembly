;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*            MEDIÇÃO DE TENSÃO E INDICAÇÃO EM % DE 5V             *
;*								  							       *
;*	       		DESENVOLVIDO POR LUCAS FERREIRA LIMA		   	   *
;*			 		     DATA: 11/09/18			  				   *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     DESCRIÇÃO DO ARQUIVO                        *
;*-----------------------------------------------------------------*
;*   ESPECIFICAÇÕES:											   *
;* • A CONVERSÃO A/D DEVE SER FEITA EM 8 BITS PELA PORTA GP2;	   *
;* • FAÇA A AQUISIÇÃO 32 VALORES PARA CALCULAR A MÉDIA DE CADA     *
/*   MEDIDA;													   *
;* • A CONVERSÃO A/D DEVE SER EFETUADA, EM MODO CÍCLICO E TÃO      *
;*	 RÁPIDO QUANTO POSSÍVEL (LIMITADO PELA VELOCIDADE DO 		   *
;*   MICROCONTROLADOR);											   * 
;* • O VALOR DA MÉDIA CONVERSÃO A/D DEVE SER TRANSFORMADO PARA O   *
;*   CORRESPONDENTE PERCENTUAL DE TENSÃO, COM 100% CORRESPONDENDO  *
;*   A 5V;														   *
;* • O VALOR DO PERCENTUAL DA TENSÃO, EM NOTAÇÃO DE BASE DECIMAL,  *
;*   DEVE SER VISUALIZADO NO DISPLAY LCD;						   *
;* • O VALOR MOSTRADO NO DISPLAY DEVE SER ATUALIZADO A CADA 200 MS;*
;* • FAÇA REUSO DAS SUAS ROTINAS DESENVOLVIDAS NA ATIVIDADE 2/AV2  *
;*	 PARA INDICAÇÃO NO LCD;										   *
;* • VEJA ALGUNS EXEMPLOS:										   *
;* 			TENSÃO MEDIDA (V) | VALOR MOSTRADO NO DISPLAY		   *
;*			   	  0,4 		  |		 		8 %					   *
;*   	   		  1,8 		  |			   36 %					   *
;*   	 		  2,7 		  |			   54 %					   *
;*   	  		  4,5 		  |			   90 %					   *
;*   	  		  5,0 		  |			  100 %					   * 
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     ARQUIVOS DE DEFINIÇÕES                      *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
#INCLUDE <p12f675.inc>	;ARQUIVO PADRÃO MICROCHIP PARA 12F675

	__CONFIG _BODEN_OFF & _CP_OFF & _PWRTE_ON & _WDT_OFF & _MCLRE_ON & _INTRC_OSC_NOCLKOUT

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                    PAGINAÇÃO DE MEMÓRIA                         *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;DEFINIÇÃO DE COMANDOS DE USUÁRIO PARA ALTERAÇÃO DA PÁGINA DE MEMÓRIA
#DEFINE	BANK0	BCF STATUS,RP0	;SETA BANK 0 DE MEMÓRIA
#DEFINE	BANK1	BSF STATUS,RP0	;SETA BANK 1 DE MAMÓRIA

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                         VARIÁVEIS                               *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DOS NOMES E ENDEREÇOS DE TODAS AS VARIÁVEIS UTILIZADAS 
; PELO SISTEMA

	CBLOCK	0x20	;ENDEREÇO INICIAL DA MEMÓRIA DE
					;USUÁRIO
		W_TEMP		;REGISTRADORES TEMPORÁRIOS PARA USO
		STATUS_TEMP	;JUNTO ÀS INTERRUPÇÕES
		D1
		D2
		
		CONT
		CONT1
		;  7   6   5    4   3    2    1    0
 		;| * | * | BL | RS | D4 | D5 | D6 | D7 |
		SHIFT		;VARIAVEL A SER PASSADA PARA O SHIFTREG
		SHIFT_CONT	;CONTADOR AUXILIAR P SUBROTINA DO SHIFTREG
		
		;  7   6   5    4   3    2    1    0
 		;| DB7 | DB6 | DB5 | DB4 | DB3 | DB2 | DB1 | DB0 |
		CMD		;USADA PARA MANDAR COMANDO PARA LCD
		AUX		;VARIAVEL AUXILIAR
		BYTE		;USADA PARA INVERTER BYTE
		
		CONTEXT		;VARIAVEL DE CONTEXTO
				;BIT 0 - BACKLIGHT
		
		AD_CON		;VALOR DA ULTIMA CONVERSÃO
				
		PERCENTAGE	;VARIAVEL AUX PARA FUNCAO DE PORCENTAGEM
		PCONT		;VARIAVEL DE CONTAGEM PARA INTERRUPÇÃO
		SHOW		;VARIAVEL AUX PARA FUNÇÃO DE PORCENTAGEM E SHOW
		
	ENDC			;FIM DO BLOCO DE MEMÓRIA
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                        FLAGS INTERNOS                           *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODOS OS FLAGS UTILIZADOS PELO SISTEMA

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                         CONSTANTES                              *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODAS AS CONSTANTES UTILIZADAS PELO SISTEMA
#DEFINE BACKLIGHT CONTEXT,0
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                           ENTRADAS                              *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODOS OS PINOS QUE SERÃO UTILIZADOS COMO ENTRADA
; RECOMENDAMOS TAMBÉM COMENTAR O SIGNIFICADO DE SEUS ESTADOS (0 E 1)

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                           SAÍDAS                                *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODOS OS PINOS QUE SERÃO UTILIZADOS COMO SAÍDA
; RECOMENDAMOS TAMBÉM COMENTAR O SIGNIFICADO DE SEUS ESTADOS (0 E 1)
#DEFINE SRCLK	GPIO, GP0
#DEFINE LCD_EN	GPIO, GP5
#DEFINE	SRDAT	GPIO, GP4
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                       VETOR DE RESET                            *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

	ORG	0x00			;ENDEREÇO INICIAL DE PROCESSAMENTO
	GOTO	INICIO
	
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                    INÍCIO DA INTERRUPÇÃO                        *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; ENDEREÇO DE DESVIO DAS INTERRUPÇÕES. A PRIMEIRA TAREFA É SALVAR OS
; VALORES DE "W" E "STATUS" PARA RECUPERAÇÃO FUTURA

	ORG	0x04			;ENDEREÇO INICIAL DA INTERRUPÇÃO
	MOVWF	W_TEMP		;COPIA W PARA W_TEMP
	SWAPF	STATUS,W
	MOVWF	STATUS_TEMP	;COPIA STATUS PARA STATUS_TEMP
	
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                    ROTINA DE INTERRUPÇÃO                        *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; AQUI SERÁ ESCRITA AS ROTINAS DE RECONHECIMENTO E TRATAMENTO DAS
; INTERRUPÇÕES
	BTFSS	PIR1, TMR1IF
	GOTO	SAI_INT
	
	MOVFW	AD_CON	;MOSTRAR PORCENTAGEM NO DISPLAY
	CALL	SHOW_PRECENTAGE_DISPLAY
		
    	MOVLW	H'50'	;RESETA TIMER
	MOVWF	TMR1H
	MOVLW	H'38'
	MOVWF	TMR1L
	BCF	PIR1, TMR1IF
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                 ROTINA DE SAÍDA DA INTERRUPÇÃO                  *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; OS VALORES DE "W" E "STATUS" DEVEM SER RECUPERADOS ANTES DE 
; RETORNAR DA INTERRUPÇÃO

SAI_INT
	SWAPF	STATUS_TEMP,W
	MOVWF	STATUS		;MOVE STATUS_TEMP PARA STATUS
	SWAPF	W_TEMP,F
	SWAPF	W_TEMP,W	;MOVE W_TEMP PARA W
	RETFIE

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*	            	 ROTINAS E SUBROTINAS                      	   *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; CADA ROTINA OU SUBROTINA DEVE POSSUIR A DESCRIÇÃO DE FUNCIONAMENTO
; E UM NOME COERENTE ÀS SUAS FUNÇÕES.

;FUNÇÃO PARA LIMPAR DISPLAY LCD
CLEAR_DISPLAY
	MOVLW	B'00000001'	;LIMPA DISPLAY
	CALL	SEND_CMD
	CALL	DELAY_2MS
	
	RETURN
	
;CONVERTE DECIMAL(0-9) PARA CARACTERE ASCII
DEC_TO_ASCII
	ADDLW	A'0'
	
	RETURN
	
;FAZ A PORCENTAGEM DE 255 PARA O VALOR RECEBIDO NO WORK
PERCENT
	CLRF	PERCENTAGE
	MOVWF	SHOW
	MOVLW	.100
	MOVWF	PCONT
	MOVFW	SHOW
PERCENT_INER			;100*W/255
	ADDWF	SHOW,F		;MULTIPLICA O NÚMERO POR 100 (REPETIDAS ADDS)
	BTFSC	STATUS,C	;E CONTA QUANTAS VEZES O VALOR ESTOROU OS 8BITS
	INCF	PERCENTAGE, F	;ESSE CONTAGEM VAI CORRESPONDER À PORCENTAGEM
	DECFSZ	PCONT		;DESCONSIDERANDO OS ULTIMOS 8BITS É O MESMO QUE
	GOTO	PERCENT_INER	;DIVIDIR POR 255
	MOVFW	PERCENTAGE
	
	RETURN

;MOSTRA VALOR DE PORCENTAGEM DO AD_CON NO DISPLAY
SHOW_PRECENTAGE_DISPLAY
	CALL	PERCENT
	MOVWF	SHOW
	CLRF	PCONT
SHOW_INNER
	MOVLW	.10	    ;DIVIDE O VALOR POR 10
	SUBWF	SHOW,W	    ;USANDO SUCESSIVAS SUBTRAÇÕES
	BTFSS	STATUS,C    ;VALOR DE RESTO SERÁ O VALOR DO DIGITO FINAL
	GOTO	SHOW_CHAR   ;VALOR DO DIVIDENDO SERÁ O DIGITO INCIAL
	MOVWF	SHOW
	INCF	PCONT
	GOTO	SHOW_INNER
SHOW_CHAR
	CALL	CLEAR_DISPLAY
	MOVLW	.10
	SUBWF	PCONT, W
	BTFSS	STATUS, Z   ;CHECA DE O DIGITO FINAL É 10
	GOTO	SHOW_ALL    ;SE NAO, PRECEDE PARA MOSTRAR O DOIS DIGITOS
	MOVLW	A'1'	    ;SE SIM, MOSTRA 10 NO DISPLAY
	CALL	SEND_CHAR
	MOVLW	A'0'
	CALL	SEND_CHAR
	GOTO	LAST_CHAR
SHOW_ALL
	MOVFW	PCONT	    
	BTFSC	STATUS,Z    ;CHECA SE O VALOR DO DIGITO INICIAL É DIF DE 0
	GOTO	LAST_CHAR   ;SE SIM, NÃO MOSTRA E VAI PARA O PROXIMO DIGITO
	CALL	DEC_TO_ASCII;SE NAO, MOSTRA DIGITO
	CALL	SEND_CHAR
LAST_CHAR	
	MOVFW	SHOW	    ;MOSTRA DIGITO FINAL
	CALL	DEC_TO_ASCII
	CALL	SEND_CHAR
	MOVLW	A'%'	    ;MANDA CHAR % PARA DISPLAY
	CALL	SEND_CHAR
	RETURN
	
	
;MOVE BYTE NO WORK PARA O REGISTRADOR DE DESLOCAMENTO
SHIFT_REG
	MOVWF	SHIFT
	MOVLW	.8
	MOVWF	SHIFT_CONT
SHIFT_LOOP
	BCF	SRDAT	    ;LIMPA BIT DE ENVIO DE DADO, SE ULTIMO BIT
	BTFSC	SHIFT, 0    ;ESTIVER EM 1, SETA BIT DE ENVIO
	BSF	SRDAT
	BSF	SRCLK	    ;PULSA CLOCK
	BCF	SRCLK
	RRF	SHIFT, F    ;ROTACIONA PARA O PROXIMO BIT
	DECFSZ	SHIFT_CONT  ;REPERE POR 8 VEZES
	GOTO	SHIFT_LOOP

	RETURN

;FUNÇÃO PARA PULSO DO ENABLE
SEND_INPUT
	BSF	LCD_EN
	BCF	LCD_EN
	
	RETURN
	
DELAY_40US
	MOVLW	.7
	MOVWF	CONT
DELAY_INTER
	NOP
	NOP
	DECFSZ	CONT,F
	GOTO	DELAY_INTER
	
	RETURN
HERE

DELAY_15MS
			;15993 CYCLES
	MOVLW	0X7E
	MOVWF	D1
	MOVLW	0X0D
	MOVWF	D2
DELAY_15MS_0
	DECFSZ	D1, F
	GOTO	$+2
	DECFSZ	D2, F
	GOTO	DELAY_15MS_0

			;3 CYCLES
	GOTO	$+1
	NOP

			;4 CYCLES (INCLUDING CALL)
	RETURN

DELAY_6MS
			;59993 CYCLES
	MOVLW	0XDE
	MOVWF	D1
	MOVLW	0X2F
	MOVWF	D2
DELAY_6MS_0
	DECFSZ	D1, F
	GOTO	$+2
	DECFSZ	D2, F
	GOTO	DELAY_6MS_0

			;3 CYCLES
	GOTO	$+1
	NOP

			;4 CYCLES (INCLUDING CALL)
	RETURN
	
DELAY_2MS
			;19993 CYCLES
	MOVLW	0X9E
	MOVWF	D1
	MOVLW	0X10
	MOVWF	D2
DELAY_2MS_0
	DECFSZ	D1, F
	GOTO	$+2
	DECFSZ	D2, F
	GOTO	DELAY_2MS_0

			;3 CYCLES
	GOTO	$+1
	NOP

			;4 CYCLES (INCLUDING CALL)
	RETURN
	
DELAY_100US
	MOVLW	.40
	MOVWF	CONT

	NOP
	NOP
	DECFSZ	CONT,F
	GOTO	$-3
				
	RETURN

;INVERTE BITS DO BYTE
;BYTE RECEBIDO PELO WORK
INVERT_BYTE
	MOVWF	BYTE		
	MOVLW	.8
	MOVWF	CONT
	RRF	BYTE	    ;ROTACIONA BIT MAIS A DIREITA PARA O CARRY
	RLF	AUX	    ;PEGAR BIT DO CARRY E ROTACIONA PARA A POSIÇÃO
	DECFSZ	CONT	    ;MAIS A DIREITA, ASSIM INVERTENDO O BYTE
	GOTO	$-3
	MOVFW	AUX
	RETURN
;MANDA COMANDO PARA O DIPLAY
;CMD RECEBIDO PELO WORK	
SEND_CMD

	CALL	INVERT_BYTE	;INVERTE BYTE PARA ACOMODAR ARQUITETURA
	MOVWF	CMD		;DA PLACA
	MOVLW	.15
	ANDWF	CMD,W		;SELECIONA OS 4 PRIMEIRO BITS PARA ENVIAR
	MOVWF	AUX
	BTFSC	BACKLIGHT	;ATIVA BACKLIGHT SE ESTIVER ATIVO
	BSF	AUX,5
	MOVFW	AUX
	CALL	SHIFT_REG	;MOVE PARA O REGISTRADOR
	CALL	SEND_INPUT	;MANDA ENABLE PARA LCD
	SWAPF	CMD,F		;SWAP PARA PEGAR OS OUTRO 4 BITS
	MOVLW	.15
	ANDWF	CMD,W
	MOVWF	AUX
	BTFSC	BACKLIGHT	;ATIVA BACKLIGHT SE ESTIVER ATIVO
	BSF	AUX,5
	MOVFW	AUX
	CALL	SHIFT_REG	;MOVE PARA O REGISTRADOR
	CALL	SEND_INPUT	;MANDA ENABLE PARA LCDs
	CALL	DELAY_100US
	
	RETURN
;MANDA CHAR PARA O DIPLAY
;CHAR RECEBIDO PELO WORK
SEND_CHAR
	CALL	INVERT_BYTE	;INVERTE BYTE PARA ACOMODAR ARQUITETURA
	MOVWF	CMD		;DA PLACA
	MOVLW	.15
	ANDWF	CMD,W		;SELECIONA OS 4 PRIMEIRO BITS PARA ENVIAR
	MOVWF	AUX		
	BSF	AUX,4		;ATIVA O RS DO DISPLAY
	BTFSC	BACKLIGHT	;ATIVA BACKLIGHT SE ESTIVER ATIVO
	BSF	AUX,5
	MOVFW	AUX
	CALL	SHIFT_REG	;MOVE PARA O REGISTRADOR
	CALL	SEND_INPUT	;MANDA ENABLE PARA LCD
	SWAPF	CMD,F		;SWAP PARA PEGAR OS OUTRO 4 BITS
	MOVLW	.15
	ANDWF	CMD,W
	MOVWF	AUX
	BSF	AUX,4
	BTFSC	BACKLIGHT	;ATIVA BACKLIGHT SE ESTIVER ATIVO
	BSF	AUX,5
	MOVFW	AUX
	CALL	SHIFT_REG	;MOVE PARA O REGISTRADOR
	CALL	SEND_INPUT	;MANDA ENABLE PARA LCD
	CALL	DELAY_100US
	RETURN

INIT_LCD
	CALL	DELAY_15MS
	MOVLW	B'00001100'	;INSTRUÇÃO DE FUNCTION SET
	CALL	SHIFT_REG
	CALL	SEND_INPUT
	
	CALL 	DELAY_6MS
	MOVLW	B'00001100'	;INSTRUÇÃO DE FUNCTION SET
	CALL	SHIFT_REG
	CALL	SEND_INPUT
	
	MOVLW	B'00001100'	;INSTRUÇÃO DE FUNCTION SET
	CALL	SHIFT_REG
	CALL	SEND_INPUT
	CALL	DELAY_100US
	
	MOVLW	B'00000100'	;INSTRUÇÃO DE FUNCTION SET
	CALL	SHIFT_REG	;DEFINIR COMUNICAÇÃO 4BITS
	CALL	SEND_INPUT
	CALL	DELAY_100US

	MOVLW	B'00101000'	;INSTRUÇÃO DE FUNCTION SET
	CALL	SEND_CMD	;ESPECIFICA DISPLAY DE 2 SEGMENTO
				;FONTE 5X7
				
	MOVLW	B'00001100'	;LIGA DISPLAY
	CALL	SEND_CMD

	MOVLW	B'00000001'	;LIMPA DISPLAY
	CALL	SEND_CMD
	
	CALL	DELAY_2MS
	
	MOVLW	B'00000110'	;INSTRUÇÃO DE FUNCTION SET
	CALL	SEND_CMD
	RETURN

;CALCULA MÉDIA DO VALORES LIDOS /// SOMA(VALORES)/32
MEAN
	CLRF	CONT1
	BSF	CONT1,0
	CLRF	AUX
	MOVLW	H'36'	 
	MOVWF	FSR
	MOVFW	INDF	
MEAN_INNER
	INCF	FSR
	ADDWF	INDF,W
	BTFSC	STATUS,C
	INCF	AUX
	INCF	CONT1	    ;ADCIONA OS VALORES LIDOS AO WORK
	BTFSS	CONT1,5	    ;USANDO A VARIAVEL AUX COMO PARTE ALTA
	GOTO	MEAN_INNER  
	INCF	FSR	    
	MOVWF	INDF
	
	RRF	AUX	    ;DIVIDINDO SOMA POR 32 (5 ROTATES PARA DIREITA)
	RRF	INDF	    ;COMO TEM BITS MAIS SIGNIFICATIVOS NA VAR AUX
			    ;USO O VALOR DO ROTATE RIGHT PARA PASSAR O BIT
	RRF	AUX	    ;MENOS SIGNIFICATIVO DA PARTE ALTA PARA O C
	RRF	INDF	    ;E PASSA ESSE BIT PARA A PARTE MAIS SIGNIFICATIVA
			    ;DA PARTE BAIXA
	RRF	AUX
	RRF	INDF
	
	RRF	AUX
	RRF	INDF
	
	RRF	AUX
	RRF	INDF
	
	MOVFW	INDF
	RETURN
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     INICIO DO PROGRAMA                          *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	
INICIO
	BANK1				;ALTERA PARA O BANCO 1
	MOVLW	B'00000100' ;CONFIGURA TODAS AS PORTAS DO GPIO (PINOS)
	MOVWF	TRISIO		;COMO SAÍDAS, MAS GP2 COMO ENTRADA
	MOVLW	B'00000100'
	MOVWF	ANSEL 		;DEFINE PORTAS COMO Digital I/O
	MOVLW	B'00000100'
	MOVWF	OPTION_REG	;DEFINE OPÇÕES DE OPERAÇÃO
	MOVLW	B'01000000'
	MOVWF	INTCON		;HABILITA INTERRUPÇÃO E INT DE PERTIFERICOS
	MOVLW	B'00000001'
	MOVWF	PIE1		;HABILITA INTERRUPÇÃO DO TMR1
	
	BANK0			;RETORNA PARA O BANCO
	MOVLW	B'00100000'	;TMR1 PRESCALE 1:4
	MOVWF	T1CON
	MOVLW	B'00000111'
	MOVWF	CMCON		;DEFINE O MODO DE OPERAÇÃO DO COMPARADOR ANALÓGICO
	MOVLW	B'00001001'
	MOVWF	ADCON0 

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     INICIALIZAÇÃO DAS VARIÁVEIS                 *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     ROTINA PRINCIPAL                            *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	BSF	BACKLIGHT	;ATIVABACKLIGHT
	CALL	INIT_LCD
	
	BCF	PIR1, TMR1IF	    ;INICIALIZA TIMER
	BSF	INTCON, GIE
	MOVLW	H'3C'
	MOVWF	TMR1H
	MOVLW	H'B0'
	MOVWF	TMR1L
	BSF	T1CON, TMR1ON
	CLRF	GPIO
	
MAIN	
	CLRF	CONT1
	MOVLW	H'36'	    ;VALORES PARA MEDIA ARMAZENADOS
	MOVWF	FSR	    ;NOS ADDRS 0X36 - 0X56
	BSF	ADCON0, 1 
MAIN_INNER		   ;REPETIÇÃO DE LEITURA DO CANAL DE CONVERSÃO			    
	CALL	DELAY_100US
	BTFSC	ADCON0, 1   ;CHECA SE CONVERSÃO ACABOU
	GOTO	$-1
	BSF	ADCON0, 1 
	MOVFW	ADRESH	    ;SE ACABOU, MOVERÁ PARA A POSIÇÃO DE MEMORIA
	MOVWF	INDF	    ;INDIRETA ATUAL E PASSARÁ PARA O PROX ADDR
	INCF	FSR
	INCF	CONT1
	BTFSS	CONT1,5	    ;CASO A CONTAGEM DE 32 AMOSTRA ACABAR
	GOTO	MAIN_INNER  ;ELE COMPUTA A MÉDIA
	CALL	MEAN	    
	MOVWF	AD_CON
	GOTO	MAIN


;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                       FIM DO PROGRAMA                           *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

	END
